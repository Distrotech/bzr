Codeville
*********

Documentation on how this actually works is pretty scarce to say the
least.

I *think* I understand their merge algorithm though, and it's pretty
clever.  Basically we do a two-way merge between annotated forms of
the two files: that is, with each line marked with the revision in
which it last changed.  (I am simplifying here by speaking of lines
and changes, but I don't think it causes any essential problem.)

Now we walk through each file, line by line.  If the change that
introduced the line state in branch A is already merged into branch B,
then we can just take B.

Now is this actually better?

It may be better in several ways:

* Do not need to choose just a single ancestor, but rather can
  take advantage of all possible previous changes.

* Can handle OTHER containing changes which have been merged into
  THIS, but have then been overwritten.

* Can handle cherrypicks(!) by remembering which lines came in from
  that cherrypick; then we don't need to merge them again.

Some questions:

* Do we actually need to store the annotations, or can we just infer
  it at the time we do the merge?

* Can this be accomodated in something like an SCCS weave format?  I
  think something like a weave may work, in as much as it is basically
  a concatenation of annotations, but I don't know if it represents
  merges well enough to cope.

Can this handle binaries or type-specific merges, and if so how?
Unmergeable binaries are easy: just get the user to pick one.  Things
like XML are harder; we probably need to punt out to a type-specific
three-way merge.  Of course this approach does not forbid also
offering a 3-way merge.

----

I suppose this could be accomodated by an annotation cache on top of
plain history storage, or by using a storage format such as a weave
that can efficiently produce annotation information.

That is to say there is nothing inherently necessary about remembering
the line history at the point when it is committed, except that it
might be more efficient to do this once and remember it than to 

----

There is another interesting approach that can be used even in a tool
that does not inherently remember annotations:

Given two files to merge, find all regions of difference.  For each
such, try to find a common ancestor having the same content for the
region.  Subdivide the region if necessary.

This naive approach is probably infeasible, since it would mean
checking every possible predecessor.

----

So the conclusion is that this is very cool, but it does not require a
fundamental change of model and can be implemented later.
