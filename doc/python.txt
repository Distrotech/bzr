Choice of Python
----------------

This will be written in Python, at least for the first cut, just for
ease of development -- I think I am at least 2-3 times faster than in
C or C++, and bugs may be less severe.  I am open to the idea of
switching to C at some time in the future, but because that is
enormously expensive I want to avoid it until it's clearly necessary.
Python is also a good platform to handle cross-platform portability.

Possible reasons to go to C:

Audience acceptance
  If Linus says "I'd use it if it were written in
  C" that would be persuasive.  I think the good developers we want to
  do not consider implementation language as a dominant factor.  A few
  related but separate questions are important to them: modest
  dependencies, easy installation, presence in distributions (or as
  packages), active support, etc.  A few queries show that Python is
  seen as relatively safe and acceptable even by people who don't
  actually use it.

Speed
  Having scalable designs is much more important.
  Secondly, we will do most of the heavy lifting in external
  C programs in the first cut, and perhaps move these into native
  libraries later.  (Subversion people had trouble in relying on GNU
  diff on legacy platforms and they had to integrate the code eventually.)

Bindings to other languages
  If we have only a Python interpretation then it can be run as a
  shell script from emacs or similar tools.  It can also be natively
  called from Python scripts, which would allow GUI bindings to almost
  every toolkit, and it can possibly be called from Java and
  .NET/Mono.    By the time this is
  mature, it's possible that Python code will be able to cross-call
  Perl and other languages through Parrot.  
  There should be enough options there to support a good
  infrastructure there of additional tools.
  If it was necessary to provide a C API that can perhaps be wrapped around a 
  Python library.

Reuse of tla code
  That may be useful, if there are substantial sections that approach
  or meet our goals for both design and implementation (e.g. being
  good to use from a library.)

  This does not necessarily mean doing the whole thing in C; we could
  call out to tla or could wrap particular bits into libraries.


----

Erik Bågfors:

  However, I think it's very important that a VCS can be wrapped in other
  languages so that it can be integrated in IDE's and have tools written
  for them.
  
  A library written in c would be simple to wrap in other languages and
  therefore could be used from for example monodevelop and friends. I
  really believe this is important for a VCS.

I agree; this is a more important argument against Python than speed,
where I think we can be entirely adequate just using smart design.
But there are some partial answers:

We can design bzr to be easily called as an external process -- not
depending on interactive input, having systematically parsed output,
--format=xml output, etc.  This is the only mode CVS supports, and
people have built many interesting tools on top of it, and it's still
popular for svn and tla.  For things like editor integration this is
often the easiest way.

Secondly, there is a good chance of calling into Python from other
languages.  There are projects like Jython, IronPython, Parrot and so
on that may well fix this.

Thirdly, we can present a Python library through a C interface; this
might seem a bit weird but I think it will work fine.  Python is
easily embeddable; this might be the best way for Windows IDE
integration.

Finally, if none of these work, then we can always recode in C,
treating Python only as a prototype.

I think working in Python I can develop it at least twice as fast as
in C, particularly in this early phase where the design is still being
worked out.  Although all other things being equal it might be nice to
be in pure C, but I don't think it's worth paying that price.

  One of the problems with darcs is that it's such a mess wrapping it.

Yes.

----

Experiments to date on large trees show that even with little
optimization, bzr is mostly disk-bound, and the CPU time usage is only
a few seconds.  That supports the position that Python performance
will be adequate.
