.. -*- mode: indented-text; compile-command: "make -C doc" -*- 


*******************
Things to do in bzr
*******************


See also various low-level TODOs in the source code.  Try looking in
the list archive or on gmane.org for previous discussion of these
issues.

These are classified by approximate size: an hour or less, a day or
less, and several days or more.


Small things
------------

* Add of a file that was present in the base revision should put back
  the previous file-id.

* Handle diff of files which do not have a trailing newline; probably
  requires patching difflib to get it exactly right, or otherwise
  calling out to GNU diff.

* Import ElementTree update patch.

* Plugins that provide commands.  By just installing a file into some
  directory (e.g. ``/usr/share/bzr/plugins``) it should be possible to
  create new top-level commands (``bzr frob``).  Extensions can be
  written in either Python (in which case they use the bzrlib API) or
  in a separate process (in sh, C, whatever).   It should be possible
  to get help for plugin commands.

* Smart rewrap text in help messages to fit in $COLUMNS (or equivalent
  on Windows)

* -r option should take a revision-id as well as a revno.

* ``bzr info`` could show space used by working tree, versioned files,
  unknown and ignored files. 

* ``bzr info`` should count only people with distinct email addresses as
  different committers.  (Or perhaps only distinct userids?)

* On Windows, command-line arguments should be `glob-expanded`__,
  because the shell doesn't do this.  However, there are probably some
  commands where this shouldn't be done, such as 'bzr ignore', because
  we want to accept globs.

* ``bzr ignore`` command that just adds a line to the ``.bzrignore`` file
  and makes it versioned.  Fix this to break symlinks.

* Any useful sanity checks in 'bzr ignore'?  Perhaps give a warning if
  they try to add a single file which is already versioned, or if they
  add a pattern which already exists, or if it looks like they gave an
  unquoted glob.

__ http://mail.python.org/pipermail/python-list/2001-April/037847.html

* Separate read and write version checks?

* ``bzr status DIR`` should give status on all files under that
  directory.

* Check all commands have decent help.

* ``bzr inventory -r REV`` and perhaps unify this with ``bzr ls``,
  giving options to display ids, types, etc.

* Atomic file class that renames into place when it's closed.

* Don't abort if ``~/.bzr.log`` can't be used.

* Split BzrError into various more specific subclasses for different
  errors people might want to catch.

* If the export destination ends in '.tar', '.tar.gz', etc then create
  a tarball instead of a directory.  (Need to actually make a
  temporary directory and then tar that up.)

  http://www.gelato.unsw.edu.au/archives/git/0504/2194.html
  
* testbzr should by default test the bzr binary in the same directory
  as the testbzr script, or take a path to it as a first parameter.

  Should show the version from bzr and the path name.

Medium things
-------------

* Display command grammar in help messages rather than hardcoding it.

* Change command functions into Command() objects, like in hct, and
  then the grammar can be described directly in there.  Since all
  option definitions are global we can define them just once and
  reference them from each command.

* Selective commit of only some files.

* Faster diff/status.  

  Status should be handled differently because it needs to report on
  deleted and unknown files.  diff only needs to deal with versioned
  files.

* Merge Aaron's merge code.

* Merge revert patch.

* Turn on stat cache code, and add optimization about avoiding
  dangerous cache entries.

* ``bzr mv`` that does either rename or move as in Unix.

* More efficient diff of only selected files.

* Fix up Inventory objects to represent root object as an entry.

* Don't convert entire entry from 

* Extract changes from one revision to the next to a text form
  suitable for transmission over email.

* More test cases.

* Write a reproducible benchmark, perhaps importing various kernel versions.

* Change test.sh from Bourne shell into something in pure Python so
  that it can be more portable.

* Directly import diffs!  It seems a bit redundant to need to rescan
  the directory to work out what files diff added/deleted/changed when
  all the information is there in the diff in the first place.
  Getting the exact behaviour for added/deleted subdirectories etc
  might be hard.

  At the very least we could run diffstat over the diff, or perhaps
  read the status output from patch.  Just knowing which files might
  be modified would be enough to guide the add and commit.
  
  Given this we might be able to import patches at 1/second or better.

* Get branch over http.

* Pull pure updates over http.

* revfile compression.

* Split inventory into per-directory files.

* Fix ignore file parsing:

  - fnmatch is not the same as unix patterns

  - perhaps add extended globs from rsh/rsync

  - perhaps a pattern that matches only directories or non-directories

* Consider using Python logging library as well as/instead of
  bzrlib.trace.

* Commands should give some progress indication by default.

  - But quieten this with ``--silent``.

* Change to using gettext message localization.

* Make a clearer separation between internal and external bzrlib
  interfaces.  Make internal interfaces use protected names.  Write at
  least some documentation for those APIs, probably as docstrings.

  Consider using ZopeInterface definitions for the external interface;
  I think these are already used in PyBaz.  They allow automatic
  checking of the interface but may be unfamiliar to general Python
  developers, so I'm not really keen.

* Commands to dump out all command help into a manpage or HTML file or
  whatever.

* Handle symlinks in the working directory; at the very least it
  should be possible for them to be present and ignored/unknown
  without causing assertion failures. 

  Eventually symlinks should be versioned.

* Allow init in a subdirectory to create a nested repository, but only
  if the subdirectory is not already versioned.   Perhaps also require
  a ``--nested`` to protect against confusion.

* Branch names? 

* More test framework:

  - Class that describes the state of a working tree so we can just
    assert it's equal.

* There are too many methods on Branch() that really manipulate the
  WorkingTree.  They should be moved across.  

  Also there are some methods which are duplicated on Tree and
  Inventory objects, and it should be made more clear which ones are
  proxies and which ones behave differently, and how.

* Try using XSLT to add some formatting to REST-generated HTML.  Or
  maybe write a small Python program that specifies a header and foot
  for the pages and calls into the docutils libraries.

* --format=xml for log, status and other commands.

* Attempting to explicitly add a file that's already added should give
  a warning; however there should be no warning for directories (since
  we scan for new children) or files encountered in a directory that's
  being scanned.

* Better handling of possible collisions on case-losing filesystems;
  make sure a single file does not get added twice under different
  names.

* Clean up XML inventory:

  - Use nesting rather than parent_id pointers.

  - Hold the ElementTree in memory in the Inventory object and work
    directly on that, rather than converting into Python objects every
    time it is read in.  Probably still expose it through some kind of
    object interface though, but perhaps that should just be a proxy
    for the elements.

  - Less special cases for the root directory. 

* Perhaps inventories should remember the revision in which each file
  was last changed, as well as its current state?  This is a bit
  redundant but might often be interested to know.


Large things
------------

* Generate annotations from current file relative to previous
  annotations.

  - Is it necessary to store any kind of annotation where data was
    deleted?

* Update revfile_ format and make it active:

  - Texts should be identified by something keyed on the revision, not
    an individual text-id.  This is much more useful for annotate I
    think; we want to map back to the revision that last changed it.

  - Access revfile revisions through the Tree/Store classes.

  - Check them from check commands.

  - Store annotations.

.. _revfile: revfile.html

* Hooks for pre-commit, post-commit, etc.

  Consider the security implications; probably should not enable hooks
  for remotely-fetched branches by default.

* Pre-commit check.  If this hook is defined, it needs to be handled
  specially: create a temporary directory containing the tree as it
  will be after the commit.  This means excluding any ignored/unknown
  files, and respecting selective commits.  Run the pre-commit check
  (e.g. compile and run test suite) in there.

* Web interface

* GUI (maybe in Python GTK+?)

* C library interface

* Expansion of $Id$ keywords within working files.  Perhaps do this in
  exports first as a simpler case because then we don't need to deal
  with removing the tags on the way back in.

* ``bzr find``
