                                                 -*- indented-text -*-

See also various low-level TODOs in the source code.  Try looking in
the list archive or on gmane.org for previous discussion of these
issues.

These are classified by approximate size: an hour or less, a day or
less, and several days or more.


Small things
------------

* Add of a file that was present in the base revision should put back
  the previous file-id.

* Handle diff of files which do not have a trailing newline; probably
  requires patching difflib to get it exactly right, or otherwise
  calling out to GNU diff.

* Import ElementTree update patch.

* Syntax should be "bzr export -r REV".

* "cat -rREV FILE"

* Plugins that provide commands.  By just installing a file into some
  directory (e.g. /usr/share/bzr/plugins) it should be possible to
  create new top-level commands ("bzr frob").  Extensions can be
  written in either Python (in which case they use the bzrlib API) or
  in a separate process (in sh, C, whatever).   It should be possible
  to get help for plugin commands.

* Smart rewrap text in help messages to fit in $COLUMNS (or equivalent
  on Windows)

* -r option should take a revision-id as well as a revno.

* "bzr info" could show space used by working tree, versioned files,
  unknown and ignored files. 

* "bzr info" should count only people with distinct email addresses as
  different committers.  (Or perhaps only distinct userids?)

* Tidier error for EPIPE: should be just "bzr: broken pipe" with no
  other details because debugging information is rarely interesting.

* On Windows, command-line arguments should be glob-expanded__,
  because the shell doesn't do this.  However, there are probably some
  commands where this shouldn't be done, such as 'bzr ignore', because
  we want to accept globs.

__ http://mail.python.org/pipermail/python-list/2001-April/037847.html

Medium things
-------------

* Faster diff/status.  

  Status should be handled differently because it needs to report on
  deleted and unknown files.  diff only needs to deal with versioned
  files.

* Merge Aaron's merge code.

* Merge revert patch.

* Turn on stat cache code, and add optimization about avoiding
  dangerous cache entries.

* mv command?

* More efficient diff of only selected files.

* Fix up Inventory objects to represent root object as an entry.

* Don't convert entire entry from 

* Extract changes from one revision to the next to a text form
  suitable for transmission over email.

* More test cases.

* Write a reproducible benchmark, perhaps importing various kernel versions.

* Change test.sh from Bourne shell into something in pure Python so
  that it can be more portable.

* Directly import diffs!  It seems a bit redundant to need to rescan
  the directory to work out what files diff added/deleted/changed when
  all the information is there in the diff in the first place.
  Getting the exact behaviour for added/deleted subdirectories etc
  might be hard.

  At the very least we could run diffstat over the diff, or perhaps
  read the status output from patch.  Just knowing which files might
  be modified would be enough to guide the add and commit.
  
  Given this we might be able to import patches at 1/second or better.

* Get branch over http.

* Pull pure updates over http.

* revfile compression.

* Split inventory into per-directory files.

* Fix ignore file parsing:

  - fnmatch is not the same as unix patterns

  - perhaps add extended globs from rsh/rsync

  - perhaps a pattern that matches only directories or non-directories

* Expansion of $Id$ tags within working files.  Perhaps do this in
  exports first as a simpler case because then we don't need to deal
  with removing the tags on the way back in.


Large things
------------

* Web interface

* GUI (maybe in Python GTK+?)

* C library interface
