#! /usr/bin/python

# Copyright (C) 2005 Canonical Ltd

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


"""External black-box test for bzr.

This always runs bzr as an external process to try to catch bugs
related to argument processing, startup, etc.

This replaces the previous test.sh which was not very portable."""

import sys, os, traceback
from os import mkdir
from os.path import exists

TESTDIR = "testbzr.tmp"

LOGFILENAME = 'testbzr.log'

try:
    import shutil
    from subprocess import call, Popen, PIPE
except ImportError, e:
    sys.stderr.write("testbzr: sorry, this test suite requires modules from python2.4\n"
                     + '    ' + str(e))
    sys.exit(1)


class CommandFailed(Exception):
    pass


def formcmd(cmd):
    if isinstance(cmd, basestring):
        logfile.write('$ %s\n' % cmd)
        cmd = cmd.split()
    else:
        logfile.write('$ %r\n' % cmd)

    if cmd[0] == 'bzr':
        cmd[0] = BZRPATH

    return cmd


def runcmd(cmd, retcode=0):
    """Run one command and check the return code.

    Returns a tuple of (stdout,stderr) strings.

    If a single string is based, it is split into words.
    For commands that are not simple space-separated words, please
    pass a list instead."""
    cmd = formcmd(cmd)
    log_linenumber()
    
    actual_retcode = call(cmd, stdout=logfile, stderr=logfile)
    
    if retcode != actual_retcode:
        raise CommandFailed("test failed: %r returned %d, expected %d"
                            % (cmd, actual_retcode, retcode))



def backtick(cmd, retcode=0):
    cmd = formcmd(cmd)
    log_linenumber()
    child = Popen(cmd, stdout=PIPE, stderr=logfile)
    outd, errd = child.communicate()
    logfile.write(outd)
    actual_retcode = child.wait()

    outd = outd.replace('\r', '')
    
    if retcode != actual_retcode:
        raise CommandFailed("test failed: %r returned %d, expected %d"
                            % (cmd, actual_retcode, retcode))

    return outd



def progress(msg):
    print '* ' + msg
    logfile.write('* '+ msg + '\n')
    log_linenumber()


def cd(dirname):
    logfile.write('$ cd %s\n' % dirname)
    os.chdir(dirname)



def log_linenumber():
    """Log the stack frame location two things up."""
    stack = traceback.extract_stack()[-3]
    logfile.write('   at %s:%d\n' % stack[:2])



# prepare an empty scratch directory
if os.path.exists(TESTDIR):
    shutil.rmtree(TESTDIR)


logfile = open(LOGFILENAME, 'wt', buffering=1)


try:
    mypath = os.path.abspath(sys.argv[0])
    print '%-30s %s' % ('running tests from', mypath)

    global BZRPATH

    if len(sys.argv) > 1:
        BZRPATH = sys.argv[1]
    else:
        BZRPATH = os.path.join(os.path.split(mypath)[0], 'bzr')

    print '%-30s %s' % ('against bzr', BZRPATH)
    print '%-30s %s' % ('in directory', os.getcwd())
    print
    print backtick([BZRPATH, 'version'])
    
    runcmd(['mkdir', TESTDIR])
    cd(TESTDIR)
    test_root = os.getcwd()

    progress("introductory commands")
    runcmd("bzr version")
    runcmd("bzr --version")
    runcmd("bzr help")
    runcmd("bzr --help")

    progress("internal tests")
    runcmd("bzr selftest")

    progress("user identity")
    # this should always identify something, if only "john@localhost"
    runcmd("bzr whoami")
    runcmd("bzr whoami --email")
    assert backtick("bzr whoami --email").count('@') == 1

    progress("invalid commands")
    runcmd("bzr pants", retcode=1)
    runcmd("bzr --pants off", retcode=1)
    runcmd("bzr diff --message foo", retcode=1)

    progress("basic branch creation")
    runcmd(['mkdir', 'branch1'])
    cd('branch1')
    runcmd('bzr init')

    assert backtick('bzr root')[:-1] == os.path.join(test_root, 'branch1')

    progress("status of new file")
    
    f = file('test.txt', 'wt')
    f.write('hello world!\n')
    f.close()

    out = backtick("bzr unknowns")
    assert out == 'test.txt\n'

    out = backtick("bzr status")
    assert out == '''?       test.txt\n'''

    out = backtick("bzr status --all")
    assert out == "?       test.txt\n"

    out = backtick("bzr status test.txt --all")
    assert out == "?       test.txt\n"

    f = file('test2.txt', 'wt')
    f.write('goodbye cruel world...\n')
    f.close()

    out = backtick("bzr status test.txt")
    assert out == "?       test.txt\n"

    out = backtick("bzr status")
    assert out == "?       test.txt\n" \
                + "?       test2.txt\n"

    os.unlink('test2.txt')

    progress("command aliases")
    out = backtick("bzr st --all")
    assert out == "?       test.txt\n"
    out = backtick("bzr stat")
    assert out == "?       test.txt\n"

    progress("command help")
    runcmd("bzr help st")
    runcmd("bzr help")
    runcmd("bzr help commands")
    runcmd("bzr help slartibartfast", 1)

    out = backtick("bzr help ci")
    out.index('aliases: ')

    progress("can't rename unversioned file")
    runcmd("bzr rename test.txt new-test.txt", 1)

    progress("adding a file")

    runcmd("bzr add test.txt")
    assert backtick("bzr unknowns") == ''
    assert backtick("bzr status --all") == "A       test.txt\n"

    progress("rename newly-added file")
    runcmd("bzr rename test.txt hello.txt")
    assert os.path.exists("hello.txt")
    assert not os.path.exists("test.txt")

    assert backtick("bzr revno") == '0\n'

    progress("add first revision")
    runcmd(["bzr", "commit", "-m", 'add first revision'])

    progress("more complex renames")
    os.mkdir("sub1")
    runcmd("bzr rename hello.txt sub1", 1)
    runcmd("bzr rename hello.txt sub1/hello.txt", 1)
    runcmd("bzr move hello.txt sub1", 1)

    runcmd("bzr add sub1")
    runcmd("bzr rename sub1 sub2")
    runcmd("bzr move hello.txt sub2")
    assert backtick("bzr relpath sub2/hello.txt") == "sub2/hello.txt\n"

    assert exists("sub2")
    assert exists("sub2/hello.txt")
    assert not exists("sub1")
    assert not exists("hello.txt")

    runcmd(['bzr', 'commit', '-m', 'commit with some things moved to subdirs'])

    mkdir("sub1")
    runcmd('bzr add sub1')
    runcmd('bzr move sub2/hello.txt sub1')
    assert not exists('sub2/hello.txt')
    assert exists('sub1/hello.txt')
    runcmd('bzr move sub2 sub1')
    assert not exists('sub2')
    assert exists('sub1/sub2')

    runcmd(['bzr', 'commit', '-m', 'rename nested subdirectories'])

    cd('sub1/sub2')
    assert backtick('bzr root')[:-1] == os.path.join(test_root, 'branch1')
    runcmd('bzr move ../hello.txt .')
    assert exists('./hello.txt')
    assert backtick('bzr relpath hello.txt') == 'sub1/sub2/hello.txt\n'
    assert backtick('bzr relpath ../../sub1/sub2/hello.txt') == 'sub1/sub2/hello.txt\n'
    runcmd(['bzr', 'commit', '-m', 'move to parent directory'])
    cd('..')
    assert backtick('bzr relpath sub2/hello.txt') == 'sub1/sub2/hello.txt\n'

    runcmd('bzr move sub2/hello.txt .')
    assert exists('hello.txt')

    f = file('hello.txt', 'wt')
    f.write('some nice new content\n')
    f.close()

    f = file('msg.tmp', 'wt')
    f.write('this is my new commit\n')
    f.close()

    runcmd('bzr commit -F msg.tmp')

    assert backtick('bzr revno') == '5\n'
    runcmd('bzr export -r 5 export-5.tmp')
    runcmd('bzr export export.tmp')
    
    cd('..')
    cd('..')

    progress('ignore patterns')
    mkdir('ignorebranch')
    cd('ignorebranch')
    runcmd('bzr init')
    assert backtick('bzr unknowns') == ''

    file('foo.tmp', 'wt').write('tmp files are ignored')
    assert backtick('bzr unknowns') == ''

    file('foo.c', 'wt').write('int main() {}')
    assert backtick('bzr unknowns') == 'foo.c\n'
    runcmd('bzr add foo.c')
    assert backtick('bzr unknowns') == ''

    file('foo.blah', 'wt').write('blah')
    assert backtick('bzr unknowns') == 'foo.blah\n'
    runcmd('bzr ignore *.blah')
    assert backtick('bzr unknowns') == ''
    assert file('.bzrignore', 'rt').read() == '*.blah\n'


    progress("all tests passed!")
except Exception, e:
    sys.stderr.write('*' * 50 + '\n'
                     + 'testbzr: tests failed\n'
                     + 'see ' + LOGFILENAME + ' for more information\n'
                     + '*' * 50 + '\n')
    logfile.write('tests failed!\n')
    traceback.print_exc(None, logfile)
    sys.exit(1)
