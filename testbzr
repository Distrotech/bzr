#! /usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (C) 2005 Canonical Ltd

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


"""External black-box test for bzr.

This always runs bzr as an external process to try to catch bugs
related to argument processing, startup, etc.

usage:

    testbzr [-p PYTHON] [BZR]

By default this tests the copy of bzr found in the same directory as
testbzr, or the first one found on the $PATH.  A copy of bzr may be
given on the command line to override this, for example when applying
a new test suite to an old copy of bzr or vice versa.

testbzr normally invokes bzr using the same version of python as it
would normally use to run -- that is, the system default python,
unless that is older than 2.3.  The -p option allows specification of
a different Python interpreter, such as when testing that bzr still
works on python2.3.

This replaces the previous test.sh which was not very portable."""

import sys, os, traceback
from os import mkdir
from os.path import exists

TESTDIR = "testbzr.tmp"

OVERRIDE_PYTHON = None

LOGFILENAME = 'testbzr.log'

try:
    import shutil
    from subprocess import call, Popen, PIPE
except ImportError, e:
    sys.stderr.write("testbzr: sorry, this test suite requires modules from python2.4\n"
                     + '    ' + str(e))
    sys.exit(1)


class CommandFailed(Exception):
    pass


def formcmd(cmd):
    if isinstance(cmd, basestring):
        cmd = cmd.split()

    if cmd[0] == 'bzr':
        cmd[0] = BZRPATH
        if OVERRIDE_PYTHON:
            cmd.insert(0, OVERRIDE_PYTHON)

    logfile.write('$ %r\n' % cmd)
    
    return cmd


def runcmd(cmd, retcode=0):
    """Run one command and check the return code.

    Returns a tuple of (stdout,stderr) strings.

    If a single string is based, it is split into words.
    For commands that are not simple space-separated words, please
    pass a list instead."""
    cmd = formcmd(cmd)
    log_linenumber()
    
    actual_retcode = call(cmd, stdout=logfile, stderr=logfile)
    
    if retcode != actual_retcode:
        raise CommandFailed("test failed: %r returned %d, expected %d"
                            % (cmd, actual_retcode, retcode))



def backtick(cmd, retcode=0):
    cmd = formcmd(cmd)
    log_linenumber()
    child = Popen(cmd, stdout=PIPE, stderr=logfile)
    outd, errd = child.communicate()
    logfile.write(outd)
    actual_retcode = child.wait()

    outd = outd.replace('\r', '')
    
    if retcode != actual_retcode:
        raise CommandFailed("test failed: %r returned %d, expected %d"
                            % (cmd, actual_retcode, retcode))

    return outd



def progress(msg):
    print '* ' + msg
    logfile.write('* '+ msg + '\n')
    log_linenumber()


def cd(dirname):
    logfile.write('$ cd %s\n' % dirname)
    os.chdir(dirname)



def log_linenumber():
    """Log the stack frame location two things up."""
    stack = traceback.extract_stack()[-3]
    logfile.write('   at %s:%d\n' % stack[:2])



# prepare an empty scratch directory
if os.path.exists(TESTDIR):
    shutil.rmtree(TESTDIR)

start_dir = os.getcwd()


logfile = open(LOGFILENAME, 'wt', buffering=1)


try:
    from getopt import getopt
    opts, args = getopt(sys.argv[1:], 'p:')

    for option, value in opts:
        if option == '-p':
            OVERRIDE_PYTHON = value
            
    
    mypath = os.path.abspath(sys.argv[0])
    print '%-30s %s' % ('running tests from', mypath)

    global BZRPATH

    if args:
        BZRPATH = args[0]
    else:
        BZRPATH = os.path.join(os.path.split(mypath)[0], 'bzr')

    print '%-30s %s' % ('against bzr', BZRPATH)
    print '%-30s %s' % ('in directory', os.getcwd())
    print '%-30s %s' % ('with python', (OVERRIDE_PYTHON or '(default)'))
    print
    print backtick([BZRPATH, 'version'])
    
    runcmd(['mkdir', TESTDIR])
    cd(TESTDIR)
    test_root = os.getcwd()

    progress("introductory commands")
    runcmd("bzr version")
    runcmd("bzr --version")
    runcmd("bzr help")
    runcmd("bzr --help")

    progress("internal tests")
    runcmd("bzr selftest")

    progress("user identity")
    # this should always identify something, if only "john@localhost"
    runcmd("bzr whoami")
    runcmd("bzr whoami --email")
    assert backtick("bzr whoami --email").count('@') == 1

    progress("invalid commands")
    runcmd("bzr pants", retcode=1)
    runcmd("bzr --pants off", retcode=1)
    runcmd("bzr diff --message foo", retcode=1)

    progress("basic branch creation")
    runcmd(['mkdir', 'branch1'])
    cd('branch1')
    runcmd('bzr init')

    assert backtick('bzr root')[:-1] == os.path.join(test_root, 'branch1')

    progress("status of new file")
    
    f = file('test.txt', 'wt')
    f.write('hello world!\n')
    f.close()

    out = backtick("bzr unknowns")
    assert out == 'test.txt\n'

    out = backtick("bzr status")
    assert out == 'unknown:\n  test.txt\n'

    out = backtick("bzr status --all")
    assert out == "unknown:\n  test.txt\n"

    out = backtick("bzr status test.txt --all")
    assert out == "unknown:\n  test.txt\n"

    f = file('test2.txt', 'wt')
    f.write('goodbye cruel world...\n')
    f.close()

    out = backtick("bzr status test.txt")
    assert out == "unknown:\n  test.txt\n"

    out = backtick("bzr status")
    assert out == ("unknown:\n"
                   "  test.txt\n"
                   "  test2.txt\n")

    os.unlink('test2.txt')

    progress("command aliases")
    out = backtick("bzr st --all")
    assert out == ("unknown:\n"
                   "  test.txt\n")
    
    out = backtick("bzr stat")
    assert out == ("unknown:\n"
                   "  test.txt\n")

    progress("command help")
    runcmd("bzr help st")
    runcmd("bzr help")
    runcmd("bzr help commands")
    runcmd("bzr help slartibartfast", 1)

    out = backtick("bzr help ci")
    out.index('aliases: ')

    progress("can't rename unversioned file")
    runcmd("bzr rename test.txt new-test.txt", 1)

    progress("adding a file")

    runcmd("bzr add test.txt")
    assert backtick("bzr unknowns") == ''
    assert backtick("bzr status --all") == ("added:\n"
                                            "  test.txt\n")

    progress("rename newly-added file")
    runcmd("bzr rename test.txt hello.txt")
    assert os.path.exists("hello.txt")
    assert not os.path.exists("test.txt")

    assert backtick("bzr revno") == '0\n'

    progress("add first revision")
    runcmd(["bzr", "commit", "-m", 'add first revision'])

    progress("more complex renames")
    os.mkdir("sub1")
    runcmd("bzr rename hello.txt sub1", 1)
    runcmd("bzr rename hello.txt sub1/hello.txt", 1)
    runcmd("bzr move hello.txt sub1", 1)

    runcmd("bzr add sub1")
    runcmd("bzr rename sub1 sub2")
    runcmd("bzr move hello.txt sub2")
    assert backtick("bzr relpath sub2/hello.txt") == os.path.join("sub2", "hello.txt\n")

    assert exists("sub2")
    assert exists("sub2/hello.txt")
    assert not exists("sub1")
    assert not exists("hello.txt")

    runcmd(['bzr', 'commit', '-m', 'commit with some things moved to subdirs'])

    mkdir("sub1")
    runcmd('bzr add sub1')
    runcmd('bzr move sub2/hello.txt sub1')
    assert not exists('sub2/hello.txt')
    assert exists('sub1/hello.txt')
    runcmd('bzr move sub2 sub1')
    assert not exists('sub2')
    assert exists('sub1/sub2')

    runcmd(['bzr', 'commit', '-m', 'rename nested subdirectories'])

    cd('sub1/sub2')
    assert backtick('bzr root')[:-1] == os.path.join(test_root, 'branch1')
    runcmd('bzr move ../hello.txt .')
    assert exists('./hello.txt')
    assert backtick('bzr relpath hello.txt') == os.path.join('sub1', 'sub2', 'hello.txt\n')
    assert backtick('bzr relpath ../../sub1/sub2/hello.txt') == os.path.join('sub1', 'sub2', 'hello.txt\n')
    runcmd(['bzr', 'commit', '-m', 'move to parent directory'])
    cd('..')
    assert backtick('bzr relpath sub2/hello.txt') == os.path.join('sub1', 'sub2', 'hello.txt\n')

    runcmd('bzr move sub2/hello.txt .')
    assert exists('hello.txt')

    f = file('hello.txt', 'wt')
    f.write('some nice new content\n')
    f.close()

    f = file('msg.tmp', 'wt')
    f.write('this is my new commit\n')
    f.close()

    runcmd('bzr commit -F msg.tmp')

    assert backtick('bzr revno') == '5\n'
    runcmd('bzr export -r 5 export-5.tmp')
    runcmd('bzr export export.tmp')

    runcmd('bzr log')
    runcmd('bzr log -v')



    progress("file with spaces in name")
    mkdir('sub directory')
    file('sub directory/file with spaces ', 'wt').write('see how this works\n')
    runcmd('bzr add .')
    runcmd('bzr diff')
    runcmd('bzr commit -m add-spaces')
    runcmd('bzr check')

    runcmd('bzr log')
    runcmd('bzr log --forward')

    runcmd('bzr info')


    



    cd('..')
    cd('..')

    progress('status after remove')
    mkdir('status-after-remove')
    # see mail from William Dod√©, 2005-05-25
    # $ bzr init; touch a; bzr add a; bzr commit -m "add a"
    #     * looking for changes...
    #     added a
    #     * commited r1
    #     $ bzr remove a
    #     $ bzr status
    #     bzr: local variable 'kind' referenced before assignment
    #     at /vrac/python/bazaar-ng/bzrlib/diff.py:286 in compare_trees()
    #     see ~/.bzr.log for debug information
    cd('status-after-remove')
    runcmd('bzr init')
    file('a', 'w').write('foo')
    runcmd('bzr add a')
    runcmd(['bzr', 'commit', '-m', 'add a'])
    runcmd('bzr remove a')
    runcmd('bzr status')

    cd('..')

    progress('ignore patterns')
    mkdir('ignorebranch')
    cd('ignorebranch')
    runcmd('bzr init')
    assert backtick('bzr unknowns') == ''

    file('foo.tmp', 'wt').write('tmp files are ignored')
    assert backtick('bzr unknowns') == ''

    file('foo.c', 'wt').write('int main() {}')
    assert backtick('bzr unknowns') == 'foo.c\n'
    runcmd('bzr add foo.c')
    assert backtick('bzr unknowns') == ''

    # 'ignore' works when creating the .bzignore file
    file('foo.blah', 'wt').write('blah')
    assert backtick('bzr unknowns') == 'foo.blah\n'
    runcmd('bzr ignore *.blah')
    assert backtick('bzr unknowns') == ''
    assert file('.bzrignore', 'rb').read() == '*.blah\n'

    # 'ignore' works when then .bzrignore file already exists
    file('garh', 'wt').write('garh')
    assert backtick('bzr unknowns') == 'garh\n'
    runcmd('bzr ignore garh')
    assert backtick('bzr unknowns') == ''
    assert file('.bzrignore', 'rb').read() == '*.blah\ngarh\n'

    cd('..')




    progress("recursive and non-recursive add")
    mkdir('no-recurse')
    cd('no-recurse')
    runcmd('bzr init')
    mkdir('foo')
    fp = os.path.join('foo', 'test.txt')
    f = file(fp, 'w')
    f.write('hello!\n')
    f.close()
    runcmd('bzr add --no-recurse foo')
    runcmd('bzr file-id foo')
    runcmd('bzr file-id ' + fp, 1)      # not versioned yet
    runcmd('bzr commit -m add-dir-only')

    runcmd('bzr file-id ' + fp, 1)      # still not versioned 

    runcmd('bzr add foo')
    runcmd('bzr file-id ' + fp)
    runcmd('bzr commit -m add-sub-file')
    
    cd('..')




    progress("all tests passed!")
except Exception, e:
    sys.stderr.write('*' * 50 + '\n'
                     + 'testbzr: tests failed\n'
                     + 'see ' + LOGFILENAME + ' for more information\n'
                     + '*' * 50 + '\n')
    logfile.write('tests failed!\n')
    traceback.print_exc(None, logfile)
    logfile.close()

    sys.stdout.writelines(file(os.path.join(start_dir, LOGFILENAME), 'rt').readlines()[-50:])
    
    sys.exit(1)

